<h2>Records</h2>
<html><body><p>Sometimes you will come across classes in your projects that are specifically meant for storing data. For these, the layout is always the same: you have your variables, getters, a constructor that takes all the information to create the object, and, in most cases, you will also want to override the <code class="language-java">toString()</code>, <code class="language-java">equals()</code>, and <code class="language-java">hashCode()</code> methods. This is where <strong>Records</strong> come to your rescue.</p>
<h5 id="records">Records</h5>
<p>A <strong>record</strong>, like classes, is a way to declare a new type in Java. Now you may wonder why we need records when we already have classes to do the same job. The answer is boilerplate code, or, more precisely, boilerplate reduction. The biggest difference from something like Lombok is that Records have language-level support, which means you don't need any third-party dependencies, so they are more attractive to use. They basically are value objects out of the box as they are immutable: their state cannot be modified once created.</p>
<h5 id="defining-records">Defining records</h5>
<p>A new Java Record is declared with the <code class="language-java">record</code> keyword followed by the name of the record and ending with parentheses. Let's create an empty record named <code class="language-java">User</code> for now. It would look like this: </p>
<pre><code class="language-java">record User() {
    // empty body
}</code></pre>
<p>Ok, now we have created our first record but it's not exactly useful just yet. Let's give the User a username and a password. We'll do that by writing the variables inside the parentheses: </p>
<pre><code class="language-java">record User(String username, String password) {
    // empty body
}</code></pre>
<p>Now our <code class="language-java">User</code> record has a username and a password variable, but where are the getters and the constructor? Those are automatically generated by the Java Compiler.</p>
<p>Now let's look at the <code class="language-java">class</code> implementation of this code:</p>
<pre><code class="language-java">public final class User {

    private final String username;
    private final String password;

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String username() {
        return username;
    }

    public String password() {
        return password;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this)
            return true;
        if (obj == null || obj.getClass() != this.getClass())
            return false;
        var that = (User) obj;
        return Objects.equals(this.username, that.username) &amp;&amp;
                Objects.equals(this.password, that.password);
    }

    @Override
    public int hashCode() {
        return Objects.hash(username, password);
    }

    @Override
    public String toString() {
        return "User[" +
                "username=" + username + ", " +
                "password=" + password + ']';
    }


}</code></pre>
<p>Here we can see the advantages of records: they reduce the need to write boilerplate code by a lot.</p>
<h5 id="custom-constructors">Custom constructors</h5>
<p>While a constructor is automatically generated for us, we can still customize its implementation:</p>
<pre><code class="language-java">public record User(String username, String password) {
    public User {
        if (username == null || password == null) {
            throw new IllegalArgumentException("Username and password must not be null");
        }
    }
}</code></pre>
<p>Notice the way the constructor is written. Unlike a class constructor, a record constructor doesn't have a formal parameter list: instead, it's just the access modifier followed by the name of the record and ending with curly brackets. This constructor type is called a <strong>compact constructor.</strong></p>
<h5 id="custom-getters">Custom getters</h5>
<p>Getters in records are named after the variable they give back. In our example above, the getter name of <code class="language-java">username</code> would be <code class="language-java">username()</code>. Now we can customize these getters by simply repeating the same method signature and inserting our code in curly brackets:</p>
<pre><code class="language-java">public record User(String username, String password) {

  public String username() {
    return username.toUpperCase(Locale.ENGLISH);
  }
}</code></pre>
<h5 id="features-and-limitations">Features and limitations</h5>
<p>So what are the limitations of records? First of all, they can't extend a class. However, you can still declare them inside another class. They are also implicitly final, which means they can't be abstract and also can't be extended by any other class, but you can still implement interfaces with them. The next restriction is that you can't declare instance fields except for the ones in the record signature, which are also immutable, so once they are created you can't change the values of a record. They can still be generic, have static components (methods, fields, and initializers) as well as constructors and instance methods. They are also compatible with annotations.</p>
<p>Let's sum this up again. Records <strong>cannot</strong>:</p>
<ul>
<li>be abstract;</li>
<li>extend classes;</li>
<li>declare instance fields;</li>
<li>be extended by classes.</li>
</ul>
<p>On the other hand, records <strong>can</strong>:</p>
<ul>
<li>be declared inside a class;</li>
<li>implement interfaces;</li>
<li>be generic;</li>
<li>be compatible with annotations;</li>
<li>have static components;</li>
<li>have constructors;</li>
<li>have instance methods.</li>
</ul>
<h5 id="conclusion">Conclusion</h5>
<p>Records are a new way to declare a type in Java, similar to classes. Using records, we can reduce the boilerplate code of immutable data classes as most of the code is generated by the compiler. They are supported on the language level and therefore don't need any third-party dependencies to work.</p></body></html>
